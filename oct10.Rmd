---
title: "oct10"
author: "Phillip Abbott"
date: "May 30, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Universe

one should have a set of lines in the euclidian plane (actually line segments, but called lines for brevity) (lines being defined by pairs of endpoints).

This set of lines has the following properties.  

* no pair of lines in the set intersect except at endpoints; when a line is added, if it intersects another line away from an endpoint, the lines are split into 2 line segments at the point of intersection 

You can:

* Add a line to it
* Add another set of lines to it
* Print the set of lines
* Rotate the set as a whole around the origin
* Translate by a vector
* Reflect in a line through the origin
* Select a subset of line segments in the set which are all line segments completely within a triangle defined by 3 points

Using the above, one will be able to create tesselations based on polygons which appear as part of the complete graph on a given number of verticies.

When a line is added, we check to see if it intersects with other lines.

For each line in the universe, compare intersection with each other line.  Create a map from line to an array of points of intersection of that line.  When you are done comparing all of them pairwise, then for each line, sort the array of points of intersection and split the line up into the appropriate number of line segments.

When determining which line segments are within a triangle, use the area condition on the endpoints.



```{r}
source("u0.R")
source("ukgraph.R")


# create the complete graph on 7 verticies.  
komplete_graphs <- list()
komplete_graphs[[7]] <- ukgraph(7)

# create the universe
the_universe <- universe()

# put the complete graph into the universe
komplete_graphs[[7]]$as_lines() %>% the_universe$add_lines()


# print the universe
the_universe$pdfa()

# Will appear in Rplots.pdf


```


```{r}

tlist <- list()
tlist[[1]] <- utriangle( komplete_graphs[[7]]$get_point(1),komplete_graphs[[7]]$get_point(2), komplete_graphs[[7]]$get_point(4))
tlist[[2]] <- utriangle( komplete_graphs[[7]]$get_point(1),komplete_graphs[[7]]$get_point(4), komplete_graphs[[7]]$get_point(5))
tlist[[3]] <- utriangle( komplete_graphs[[7]]$get_point(1),komplete_graphs[[7]]$get_point(5), komplete_graphs[[7]]$get_point(6))


xx0 <- the_universe$multisubset(tlist)

ttlist <- list()
ttlist[[1]] <- tlist[[2]]
xxx1 <- the_universe$multisubset(ttlist)

the_inscribed_polygon <- komplete_graphs[[7]]$get_inscribed_polygon()

xx1 <- xx0$copy_reflect_in_line( the_inscribed_polygon [[7]] ) 

xx2 <- xx1$copy_rotate(2*pi/7)
xx3 <- xx2$copy_rotate(2*pi/7)
xx4 <- xx3$copy_rotate(2*pi/7)
xx5 <- xx4$copy_rotate(2*pi/7)
xx6 <- xx5$copy_rotate(2*pi/7)
xx7 <- xx6$copy_rotate(2*pi/7)


the_universe$add_from_universe(xx1,TRUE)
the_universe$add_from_universe(xx2,TRUE)
the_universe$add_from_universe(xx3,TRUE)
the_universe$add_from_universe(xx4,TRUE)
the_universe$add_from_universe(xx5,TRUE)
the_universe$add_from_universe(xx6,TRUE)
the_universe$add_from_universe(xx7,TRUE)

xxx1$rotate_about_point(pi, upt(1,0))
xxx2 <- xxx1$copy_rotate(2*pi/7)
xxx3 <- xxx2$copy_rotate(2*pi/7)
xxx4 <- xxx3$copy_rotate(2*pi/7)
xxx5 <- xxx4$copy_rotate(2*pi/7)
xxx6 <- xxx5$copy_rotate(2*pi/7)
xxx7 <- xxx6$copy_rotate(2*pi/7)

the_universe$add_from_universe(xxx1,TRUE)
the_universe$add_from_universe(xxx2,TRUE)
the_universe$add_from_universe(xxx3,TRUE)
the_universe$add_from_universe(xxx4,TRUE)
the_universe$add_from_universe(xxx5,TRUE)
the_universe$add_from_universe(xxx6,TRUE)
the_universe$add_from_universe(xxx7,TRUE)


# the_universe$add_from_universe(xxx145,TRUE)




the_universe$pdf(3,6)

```





* Create the reflections in the outer edges and add to the universe


```{r}

the_inscribed_polygon <- komplete_graphs[[7]]$get_inscribed_polygon()

# the_inscribed_polygon %>% map(~.$printme())

ur <- the_inscribed_polygon %>% map(~the_universe$copy_reflect_in_line(.))

ur %>% map(~the_universe$add_from_universe(.,TRUE))


```

```{r}




the_universe$pdf(3,6)



```



# Revised Syntax.

The current scheme allows one to create geometric drawings based on subsets, translations, rotations & reflections of complete graphs.  But the syntax is 













